#!/usr/bin/perl -w

if (scalar(@ARGV) != 3) {
    print "Usage: getgoaltimes <ontime problem filename> <plan filename> <random seed>\n";
    exit(1);
}

$domainfile = "DepotsTime.pddl";

if (!(-e $domainfile)) {
    print "$domainfile does not exist\n";
    exit(2);
}

$valstring = "./validate -t 0.001 -v $domainfile";

$problem = shift(@ARGV);
$plan = shift(@ARGV);

$seed = shift(@ARGV) + 0;

# first, we open the problem, and skip to the goals

open PROBLEM, "< $problem";

while (<PROBLEM>) {
    if (m/:goal/) { last; }
}

# ...then note what crates had goals, and assume these were true at time zero

while (<PROBLEM>) {
    if (m/\(on (crate[^ ]+)/) {
       $goalattime{$1} = 0; # goalattime is a hash map, the key is the crate goal, the value is 0
    }
}

close PROBLEM;

# run VAL, capture its output...
open IN, "$valstring $problem $plan |";

$timenow = 0;

while (<IN>) {
    # when val gets to the next action start/end, update $timenow
    if (m/Checking next happening \(time ([0-9\.]+)/) {
        $timenow = $1 + 0;
    }
    # then, if we see that a crate has arrived, make a note of when this was
    if (m/Adding \(on (crate[^ ]+)/ && exists($goalattime{$1})) {
        $goalattime{$1} = $timenow;
    }
}

close IN;

open OUT, "> withdeadlines-$problem-$seed";
open PROBLEM, "< $problem";

# write everything up to the :init line to the output file
while (<PROBLEM>) {
    print OUT;
    if (m/:init/) { last; }
}

my @keyarray = (keys %goalattime);

my @sortedkeys = sort @keyarray;

srand($seed);

# ...then write the deadlines
foreach $crate (@sortedkeys) {
    $achievedat = $goalattime{$crate};
    if ($achievedat == 0) {
        print OUT "; The goal for $achievedat was achieved at time zero (in the initial state), so no deadline was generated\n";
    } else {
        $perturbment = rand(100) - 50;
        $achievedat = $achievedat + $perturbment; # add something between [-50,50) to the deadline
        print OUT "(at $achievedat (not (still-on-time $crate))) ; deadline on when $crate got to its goal location\n"
    }
}

# ...then write the rest
while (<PROBLEM>) { print OUT; }

close PROBLEM;
close OUT;